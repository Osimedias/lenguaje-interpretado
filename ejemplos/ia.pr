// red neuronal para aprender a 
// reconocer un digito representado en 7 segmentos

decimales 8
factor_apr = 0.5
e =  2.718281828
epsilon = 0.0000000001

factor = 5
factor2 = 7

PALABRA = ' '
vaciar PALABRA
imprimir 'dim SEGM'
dim SEGM 9
SEGM[0] = '1110111'
SEGM[1] = '1000001'
SEGM[2] = '1101110'
SEGM[3] = '1101011'
SEGM[4] = '1011001'
SEGM[5] = '0111011'
SEGM[6] = '0111111'
SEGM[7] = '1100001'
SEGM[8] = '1111111'
SEGM[9] = '1111011'
imprimir 'dim APRENDER'
dim APRENDER 9
APRENDER[0] = '0000'
APRENDER[1] = '0001'
APRENDER[2] = '0010'
APRENDER[3] = '0011'
APRENDER[4] = '0100'
APRENDER[5] = '0101'
APRENDER[6] = '0110'
APRENDER[7] = '0111'
APRENDER[8] = '1000'
APRENDER[9] = '1001'

cantidad = 7

//capa de entrada
imprimir 'dim entradas 7'
dim entradas  7

//capa de enmedio
imprimir 'dim capa 5'
dim capa       5
imprimir 'dim peso 35'
dim peso      35  // 7 * 5
imprimir 'dim err 5'
dim err        5
imprimir 'dim umbral 5'
dim umbral     5   




imprimir 'dim capa2 5'
dim capa2       5
imprimir 'dim peso2 35'
dim peso2      35  // 7 * 5
imprimir 'dim err2 5'
dim err2        5
imprimir 'dim umbral2 5'
dim umbral2     5   



dim umbral_s   4   
desde i=0 hasta 4
{
    capa[i] = 0
    capa2[i] = 0
    umbral[i] = 0.5
    umbral2[i] = 0.5
}

desde i=0 hasta 34
{
    peso[i] = 0.5
    peso2[i] = 0.5
    imprimir i, ' ', peso [i]
    
}

// capa de salida
imprimir 'dim salidas 4'
dim salidas   4
imprimir 'dim peso_s 20'
dim peso_s    20 // 5*4
imprimir 'dim umbral_s 5'

desde i = 0 hasta 3
{

	umbral_s[i] = 0.5
	//salidas[i] = 0
}

desde i=0 hasta 19
{
    peso_s[i] = 0.5
    umbral_s[i] = 0.5
}


ddd = 9
contador1 = 0
//imprimir 'limite  iteraciones? '
//leer iteraciones

// cuerpo del programa principal
// primera etapa: aprendizaje
acaba = 0
mientras acaba = 0
{
cantidad = 7

imprimir 'que segmento? '
leer ddd

imprimir 'limite  iteraciones? '
leer iteraciones
//segmn=9
contador = 0
mientras contador < iteraciones
{
	desde segmn = ddd hasta ddd
	{
		// cargar la capa de entrada con datos
		j = cargar_entradas(segmn)   //ponemos datos en la carpeta de entrada
		//imprimir 'entrada:'
		//llamar ver_entradas
		//imprimir 'aprender: '
		VAR_APR = APRENDER[segmn]
		//imprimir  VAR_APR
		
		//imprimir 'en medio:'
		desde var=0 hasta 4
		{
			z = activacion_capa_enmedio(var)
		}

		desde var=0 hasta 4
		{
			z = activacion_capa_enmedio2(var)
		}
		
		//llamar ver_capa_enmedio
		desde var=0 hasta 3
		{
			z = activacion_capa_salida(var)
		}
		//llamar ver_capa_salida
		hay_error = 0
		llamar calcular_error
		si hay_error = 0 entonces
			salir
		si-fin
		//imprimir '-----------------------------------------------------------------------'
	}	
	contador = contador + 1
	contador1 = contador1 +  1
	si contador1 = 100 entonces
		imprimir contador
		contador1 = 0
	si-fin
	//imprimir contador
}
imprimir 'salida: '
//llamar activacion_capa_salida
llamar ver_capa_salida
imprimir VAR_APR
imprimir 'acaba?'
leer acaba
}


segm = 0
imprimir 'introduce un numero del 0 al 9'
leer segm
z=cargar_entradas(segm)
desde var=0 hasta 4
		{
			z = activacion_capa_enmedio(var)
		}
		
		//llamar ver_capa_enmedio
		desde var=0 hasta 3
		{
			z = activacion_capa_salida(var)
		}
llamar ver_capa_salida


//error (en la salida)=(salida correcta - salida actual) * salida actual  * (1 - salida actual)
//pesoJK = pesoJK + factor_apr*errorK*Oj
//Oj es la salida con funcion zigmoide.

//error (en las capas interiores) debe ser la sumatoria
// Ej = Oj*(1-Oj)*sumatoria ( Ek * Wjk)

terminar



















proc calcular_error
desde i=0 hasta largo(VAR_APR) - 1   //desde 0 hasta 3   por cada neurona de salida
{
   DIGITO = subcadena(VAR_APR, i + 1 , 1 )
   convertir DIGITO digito
   dig_salida = salidas [i]
   error = 0
   error = (digito - dig_salida)
   er = error
   si er < 0 entonces
		er = er * ( -1 )
   si-fin
   
   si (er>epsilon) entonces
		hay_error = 1
   sino
		hay_error = 0
		salir
   si-fin
   
   si hay_error = 1 entonces
		   error = error * dig_salida * ( 1 - dig_salida)  //error en la salida (i)
		   //pausa
		   //imprimir 'error = ', error
		   umbral_s[i] = umbral_s[i] + (factor_apr * error * dig_salida)
		   suma2 = 0
		   desde j  = 0 hasta 4   // una por cada peso entre la capa del medio y la salida
			{ 
					  indice = (i*factor) + j
					  suma2 = suma2 + (error * peso_s [indice])
					  peso_s [ indice ] = peso_s [ indice ] + (factor_apr * error *  capa2[j])
					  err2[j] =  err2[j]  + suma2
				      //imprimir ' fila, columna, indice = ', i, '  ', j, '  ', indice, peso_s[indice]
					 // imprimir 'peso_s , indice : ', peso_s [ indice ] , '      ', indice
					  //umbral [j] = umbral[j] + factor_apr * error * capa[j]
			}
	si-fin
}

// capa2 ( penultima  )
si hay_error = 1 entonces
		desde k = 0 hasta 6       //  7 iteraciones, uno por cada peso entre la inicial y la capa del medio
		{
			   suma3 = 0
			   desde j  = 0 hasta 4   // una por cada peso entre la capa del medio y la salida
			   {
			   	  indice = (k*factor2) + j
				  err2[j] = err2[j] * capa2 [j] * ( 1 - capa2[j]  )
				  error = err2[j]

				  suma3 = suma3 + (error * peso2 [indice])
				  err[j] =  err[j]  + suma3

				  //imprimir ' fila, columna, indice = ', k, '  ', j, '  ', indice, peso[indice]
				  peso2 [indice] = peso2 [indice] + ( factor_apr * err2[j] *  capa[k] )   // entrada [k] )
				  //imprimir 'peso , indice : ', peso [ indice ] , '      ', indice
				  umbral2 [j] = umbral2[j] + (factor_apr * err2[j] * capa2[k])
				  //umbral [j] = umbral[j] + factor_apr * error * capa[j]
			   }
			   //stop
		}
si-fin


si hay_error = 1 entonces
		desde k = 0 hasta 6       //  7 iteraciones, uno por cada peso entre la inicial y la capa del medio
		{
			   desde j  = 0 hasta 4   // una por cada peso entre la capa del medio y la salida
			   {
				  err[j] = err[j] * capa [j] * ( 1 - capa[j]  )
				  indice = (k*factor2) + j
				  //imprimir ' fila, columna, indice = ', k, '  ', j, '  ', indice, peso[indice]
				  peso [indice] = peso [indice] + ( factor_apr * err[j] *  entrada [k] )
				  //imprimir 'peso , indice : ', peso [ indice ] , '      ', indice
				  umbral [j] = umbral[j] + (factor_apr * err[j] * capa[k])
				  //umbral [j] = umbral[j] + factor_apr * error * capa[j]
			   }
			   //stop
		}
si-fin

//imprimir 'fin calcular error'
fin






















// procedimientos y funciones

funcion activacion_capa_enmedio(indice)
    suma = 0
    desde i=0 hasta 6
    {
		indice2 = (indice*factor2)+i
		//imprimir '  fila,  columna, indice  = ', indice, '  ', i, '  ', indice2, peso[indice2]
        suma = suma + entradas[i] * peso[indice2]
    }
    suma = suma + umbral[indice]
    //imprimir 'suma = ', suma
    activacion_u = sigmoide(suma)
	//imprimir 'en medio: ', activacion_u
    //imprimir 'activacion: ', activacion_u
    llamar  llena_salidas_enmedio
    retornar z
fin


funcion activacion_capa_enmedio2(indice)
    suma = 0
    desde i=0 hasta 6
    {
		indice2 = (indice*factor2)+i
		//imprimir '  fila,  columna, indice  = ', indice, '  ', i, '  ', indice2, peso[indice2]
        suma = suma + capa[i] * peso2[indice2]
    }
    suma = suma + umbral2[indice]
    //imprimir 'suma = ', suma
    activacion_u = sigmoide(suma)
	//imprimir 'en medio: ', activacion_u
    //imprimir 'activacion: ', activacion_u
    llamar  llena_salidas_enmedio2
    retornar z
fin


funcion activacion_capa_salida(indice)
    suma = 0
    desde i=0 hasta 4
    {
		indice2 = (indice*factor)+i
		//imprimir '  fila,  columna, indice  = ', indice, '  ', i, '  ', indice2, peso[indice2]
        suma = suma + capa2[i] * peso_s[indice2]
    }
    suma = suma + umbral_s[indice]
    //imprimir 'suma = ', suma
    activacion_u = sigmoide(suma)
	//imprimir 'en salida: ', activacion_u
    //imprimir 'activacion: ', activacion_u
    llamar  llena_salidas_salida
    retornar z
fin











proc llena_salidas_enmedio
    capa[indice] = activacion_u
fin

proc llena_salidas_enmedio2
    capa2[indice] = activacion_u
fin

proc  llena_salidas_salida
		//no se podra indexar una variable no array,cuidado!
        salidas[indice] = activacion_u
		//imprimir '<<', indice, salidas[indice]
fin





proc ver_capa_enmedio
 desde i=0 hasta 4
 {
    imprimir 'capa ', i, ': ',  capa[i]
 }
fin

proc ver_capa_salida
 desde i=0 hasta 3
 {
    imprimir 'salida ', i, ': ',  salidas[i]
 }
fin



funcion sigmoide(suma)
    //e =  2.718281828
    exponente = suma * (-1)
    s = 1 / (1 + potencia(e, exponente))
    retornar s
fin

proc ver_entradas
 desde i=0 hasta 6
 {
    imprimir 'entrada ', i, ': ',  entradas[i]
 }
fin


funcion cargar_entradas(indice)
    PALABRA = SEGM[indice]
    desde segm = 1 hasta 7
    {
        DIGITO  = subcadena (PALABRA, segm, 1)
        digito = 0
        convertir DIGITO digito
        entradas[segm-1] = digito
    }
	 
fin




	
proc mostrar_pesos
imprimir 'primeros pesos'
desde i = 0 hasta 6
{
	desde j = 0 hasta 4
	{
		imprimir i, ' , ', j, '  --  ', peso[(i*factor2)+j]
	}

}

imprimir 'segundos pesos'
desde i = 0 hasta 6
{
	desde j = 0 hasta 4
	{
		imprimir i, ' , ', j, '  --  ', peso2[(i*factor2)+j]
	}
}

imprimir 'ultimos pesos'
desde i = 0 hasta 4
{
	desde j = 0 hasta 3
	{
		imprimir i, ' , ', j, '  --  ', peso_s[(i*factor)+j]
	}
}

fin


